--https://www.openssh.com/txt/socks4.protocol--
SOCKS: протокол для TCP-прокси через брандмауэры

Ying-Da Lee
Главный член Технический персонал
Лаборатория систем NEC, CSTC
ylee@syl.dl.nec.com

SOCKS изначально был разработан Дэвидом Кобласом, а затем изменен и расширен мной до текущей версии — версии 4. 
Это протокол, который ретранслирует сеансы TCP на хост брандмауэра, чтобы предоставить пользователям приложений прозрачный доступ через брандмауэр. Поскольку протокол
независим от протоколов приложений, его можно (и использовалось) для
множества различных служб, таких как telnet, ftp, finger, whois, gopher, WWW и т. д. Контроль доступа может применяться в начале каждого сеанса TCP;
после этого сервер просто ретранслирует данные между клиентом и
сервером приложений, неся минимальные накладные расходы на обработку. Поскольку SOCKS
никогда не должен знать ничего о протоколе приложения, ему также должно быть легко размещать приложения, которые используют шифрование для защиты
своего трафика от любопытных шпионов.

Определены две операции: CONNECT и BIND.

1) CONNECT

Клиент подключается к серверу SOCKS и отправляет запрос CONNECT, когда
хочет установить соединение с сервером приложений. Клиент
включает в пакет запроса IP-адрес и номер порта хоста назначения, а также идентификатор пользователя в следующем формате.

                +----+----+----+----+----+----+----+----+----+----+....+----+
		        | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|
		        +----+----+----+----+----+----+----+----+----+----+....+----+
Количесво байт:    1    1      2              4           variable       1

VN — номер версии протокола SOCKS, должен быть равен 4. CD — код
команды SOCKS, должен быть равен 1 для запроса CONNECT. NULL — байт, состоящий из
всех нулевых битов.

Сервер SOCKS проверяет, следует ли удовлетворять такой запрос,
на основе любой комбинации исходного IP-адреса, IP-адреса назначения,
номера порта назначения, идентификатора пользователя и информации, которую он может получить,
сверившись с IDENT, см. RFC 1413. Если запрос удовлетворяется, сервер SOCKS устанавливает соединение с указанным портом хоста назначения.
Пакет ответа отправляется клиенту, когда это соединение установлено,
или когда запрос отклонен или операция не выполнена.

+----+----+----+----+----+----+----+----+
| VN | CD | DSTPORT |       DSTIP       |
+----+----+----+----+----+----+----+----+
   1    1      2              4

VN — это версия кода ответа, которая должна быть равна 0. CD — это код результата с одним из следующих значений:

90: запрос удовлетворен

91: запрос отклонен или не выполнен
92: запрос отклонен, так как сервер SOCKS не может подключиться к
identd на клиенте
93: запрос отклонен, так как клиентская программа и identd
сообщают разные идентификаторы пользователей

Остальные поля игнорируются.

Сервер SOCKS закрывает свое соединение немедленно после уведомления
клиента о неудачном или отклоненном запросе. Для успешного запроса сервер SOCKS готов ретранслировать трафик в обоих направлениях. Это
позволяет клиенту выполнять ввод-вывод на своем соединении, как если бы он был напрямую
подключен к серверу приложений.
2) BIND

Клиент подключается к серверу SOCKS и отправляет запрос BIND, когда
хочет подготовиться к входящему подключению с сервера приложений.
Это должно происходить только после того, как основное подключение к серверу приложений
было установлено с помощью CONNECT. Обычно это часть
последовательности действий:

-bind(): получить сокет
-getsockname(): получить IP-адрес и номер порта сокета
-listen(): готов принять вызов от сервера приложений
-использовать основное подключение, чтобы сообщить серверу приложений
IP-адрес и номер порта, к которому он должен подключиться.
-accept(): принять подключение от сервера приложений

Целью операции SOCKS BIND является поддержка такой последовательности,
но с использованием сокета на сервере SOCKS, а не на клиенте.

Клиент включает в пакет запроса IP-адрес сервера приложений, порт назначения, используемый в основном подключении,
и идентификатор пользователя.

+----+----+----+----+----+----+----+----+----+----+....+----+
| VN | CD | DSTPORT |       DSTIP       |     USERID   |NULL|
+----+----+----+----+----+----+----+----+----+....+----+----+
  1    1       2              4            variable       1
Количество байтов: 1 1 2 4 переменная 1

VN снова равен 4 для номера версии протокола SOCKS. CD должен быть равен 2, чтобы указать запрос BIND.

Сервер SOCKS использует информацию о клиенте, чтобы решить, следует ли удовлетворить запрос. Ответ, который он отправляет обратно клиенту, имеет тот же формат, что и ответ на запрос CONNECT, т. е.

            +----+----+----+----+----+----+----+----+
            | VN | CD | DSTPORT |       DSTIP       |
            +----+----+----+----+----+----+----+----+
              1     1      2              4
Количество байтов: 1 1 2 4

VN — это версия кода ответа, которая должна быть равна 0. CD — это код результата с одним из следующих значений:

90: запрос удовлетворен

91: запрос отклонен или не выполнен

92: запрос отклонен, так как сервер SOCKS не может подключиться к
identd на клиенте

93: запрос отклонен, так как клиентская программа и identd
сообщают разные идентификаторы пользователей.

Однако для удовлетворенного запроса (CD равен 90) поля DSTPORT и DSTIP
имеют смысл. В этом случае сервер SOCKS получает сокет для ожидания
входящего соединения и отправляет номер порта и IP-адрес
этого сокета клиенту в DSTPORT и DSTIP соответственно. Если
DSTIP в ответе равен 0 (значение константы INADDR_ANY), то
клиент должен заменить его на IP-адрес сервера SOCKS, к которому
подключен клиент. (Это происходит, если сервер SOCKS не является
многосетевым хостом.) В типичном сценарии эти два числа
предоставляются клиентской программе приложения через результат
последующего вызова getsockname(). Протокол приложения должен
предоставлять способ отправки этих двух фрагментов информации от клиента на сервер приложений, чтобы он мог инициировать соединение, которое
подключает его к серверу SOCKS, а не напрямую к клиенту приложения, как это обычно бывает.

Сервер SOCKS отправляет клиенту второй ответный пакет, когда
ожидаемое соединение с сервером приложений установлено.
Сервер SOCKS проверяет IP-адрес исходного хоста по
значению DSTIP, указанному в запросе клиента BIND. Если обнаружено несоответствие,
поле CD во втором ответе устанавливается на 91, и сервер SOCKS закрывает оба соединения. Если они совпадают, CD во втором
ответе устанавливается на 90, и сервер SOCKS готовится ретранслировать трафик
по своим двум соединениям. С этого момента клиент выполняет ввод-вывод на своем соединении
с сервером SOCKS, как если бы он был напрямую подключен к серверу приложений.

Для операций CONNECT и BIND сервер устанавливает ограничение по времени
(2 минуты в текущей реализации CSTC) для установления
соединения с сервером приложений. Если соединение все еще не
установлено по истечении ограничения по времени, сервер закрывает свое соединение
с клиентом и сдается.
